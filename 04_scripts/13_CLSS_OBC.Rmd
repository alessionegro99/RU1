---
title: "SS."
output:
  html_document: def
---
Loading the required library

```{r}
library(hadron)
```

Initializing stuff

```{r echo = FALSE}
rawdata <- "/home/negro/projects/matching/RU1/01_rawdata/OBC/"
plots <- "/home/negro/projects/matching/RU1/02_output/plots/OBC/"
data <- "/home/negro/projects/matching/RU1/02_output/data/OBC/"
plots_SS <- "/home/negro/projects/matching/RU1/02_output/plots/SS/OBC/"

r_L3 <- c(1, sqrt(2), 2, sqrt(5), sqrt(8))
r_L4 <- c(1, sqrt(2), 2, sqrt(5), sqrt(8), sqrt(10), sqrt(18))
r_L5 <- c(1, sqrt(2), 2, sqrt(5), sqrt(8), sqrt(10), sqrt(18), 5, sqrt(32))

b_L3 <- c(1.4, 1.7, 2, 3, 5, 10, 15, 20, 25, 30, 40, 50, 60, 80, 90, 100)
b_L4 <- c(5, 8, 10, 20, 30, 40, 60, 80)
b_L5 <- c(10, 20, 30, 40, 50, 60, 80, 100)
```

g(beta) for L = 3

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"

mask_r <- c(2, 4, 5)
mask_b <- seq(1, length(b_L3))

rr <- r_L3[mask_r]
bb <- b_L3[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(bb))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "blue", pch = 2, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "blue", pch = 6, cex = 1.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "3x3"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "3x3")),
       pch = c(2, 6),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("blue", "blue"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```
g(beta) for L = 4

```{r}
temporal_extent <- 32
spatial_extent <- 4
boot.R = 500
x0 = "_0"

mask_r <- c(2, 6, 7) # sqrt2 sqrt10 sqrt18
mask_b <- seq(1, length(b_L4))

rr <- r_L4[mask_r]
bb <- b_L4[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "red", pch = 1, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "red", pch = 1, cex = 0.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "4x4"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "4x4")),
       pch = c(1, 1),  # Point types
       pt.cex = c(1.5, 0.5),  # Point sizes
       col = c("red", "red"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L = 5

```{r}
temporal_extent <- 32
spatial_extent <- 5
boot.R = 500
x0 = "_0"

mask_r <- c(4, 8, 9) # sqrt5 5 sqrt32
mask_b <- seq(1, length(b_L5))

rr <- r_L5[mask_r]
bb <- b_L5[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "orange", pch = 0, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "orange", pch = 8, cex = 1.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "4x4"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "4x4")),
       pch = c(0, 8),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("orange", "orange"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g1,g2(beta) for L = 3, every possible discretization of the derivative, combined

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"
pdf(paste0(plots_SS, "g1_g2_vs_beta_L_combinations.pdf"))

for (ii in seq(1, length(r_L3) - 2)){
  for(jj in seq(ii + 1, length(r_L3) - 1)){
    for(kk in seq(jj + 1, length(r_L3))){
      
      # removing non physical couplings
      if( ((ii == 1) && (jj == 3) && (kk == 4)) || ((ii == 2) && (jj == 3) && (kk == 4)) || ((ii == 3) && (jj == 4) && (kk == 5)))
      {
        next
      }

      mask_r <- c(ii, jj, kk) 
      mask_b <- seq(1, length(b_L3))
      
      rr <- r_L3[mask_r]
      bb <- b_L3[mask_b]
      
      V <- rep(NA, length(rr))
      bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
      g1 <- rep(NA, length(bb))
      bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      g2 <- rep(NA, length(bb))
      bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      
      for(i in seq_along(bb))
      {
        folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
          
        for(j in seq_along(rr))
        {
          tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
          
          V[j] <- tmp$t0[[2]]
          bsV[,j] <- tmp$t[,2]
        }
        rm(tmp)
        
        g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
        g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])


        bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
        bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])

      }
      rm(V)
      rm(bsV)
      
      dg1 <- apply(bsg1, 2, sd)
      dg2 <- apply(bsg2, 2, sd)
      
      # Define the random_color function
      random_color <- function() {
        red <- sample(0:255, 1)
        green <- sample(0:255, 1)
        blue <- sample(0:255, 1)
        color <- rgb(red, green, blue, maxColorValue = 255)
        return(color)
      }

      # Generate a random color
      my_color <- random_color()
    
      if((ii == 1) && (jj == 2) && (kk == 3)){
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      main = paste0("g1(beta), g2(beta), L=3, different derivative discretizations"),
                      xlab = "beta=1/g²", ylab = "r²F(r,g)",
                      log = "x",
                      xlim = c(bb[1], bb[length(bb) - 12]), ylim = c(0, 2.4))
        grid()
        
        legend_vec <- c(paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(my_color)
      }
      else{
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      rep = TRUE)
        legend_vec <- c(legend_vec, paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(col_vec, my_color)
      }
      plotwitherror(bb, g2, dg2, col = my_color, pch = 6, cex = 1,
                    rep = TRUE)
    }
  }
}
legend(x = "topright",
       legend = legend_vec,
       pch = 11,
       col = col_vec)
dev.off()
```

g1(beta) for L = 3, every possible discretization of the derivative, combined

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"
pdf(paste0(plots_SS, "g1_vs_beta_L_combinations.pdf"))

for (ii in seq(1, length(r_L3) - 2)){
  for(jj in seq(ii + 1, length(r_L3) - 1)){
    for(kk in seq(jj + 1, length(r_L3))){
      
      # removing non physical couplings
      if( ((ii == 1) && (jj == 3) && (kk == 4)) || ((ii == 2) && (jj == 3) && (kk == 4)) || ((ii == 3) && (jj == 4) && (kk == 5)))
      {
        next
      }

      mask_r <- c(ii, jj, kk) 
      mask_b <- seq(1, length(b_L3))
      
      rr <- r_L3[mask_r]
      bb <- b_L3[mask_b]
      
      V <- rep(NA, length(rr))
      bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
      g1 <- rep(NA, length(bb))
      bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      
      for(i in seq_along(bb))
      {
        folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
          
        for(j in seq_along(rr))
        {
          tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
          
          V[j] <- tmp$t0[[2]]
          bsV[,j] <- tmp$t[,2]
        }
        rm(tmp)
        
        g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])

        bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
      }
      rm(V)
      rm(bsV)
      
      dg1 <- apply(bsg1, 2, sd)
      dg2 <- apply(bsg2, 2, sd)
      
      # Define the random_color function
      random_color <- function() {
        red <- sample(0:255, 1)
        green <- sample(0:255, 1)
        blue <- sample(0:255, 1)
        color <- rgb(red, green, blue, maxColorValue = 255)
        return(color)
      }

      # Generate a random color
      my_color <- random_color()
    
      if((ii == 1) && (jj == 2) && (kk == 3)){
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      main = paste0("g1(beta), L=3, different derivative discretizations"),
                      xlab = "beta=1/g²", ylab = "r1²F(r1,g)",
                      log = "x",
                      xlim = c(bb[1], bb[length(bb) - 12]), ylim = c(0, 0.85))
        grid()
        
        legend_vec <- c(paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2)))
        col_vec <- c(my_color)
      }
      else{
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      rep = TRUE)
        legend_vec <- c(legend_vec, paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2)))
        col_vec <- c(col_vec, my_color)
      }
    }
  }
}
legend(x = "topright",
       legend = legend_vec,
       pch = 2,
       col = col_vec)
dev.off()
```

g2(beta) for L = 3, every possible discretization of the derivative, combined

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"
pdf(paste0(plots_SS, "g2_vs_beta_L_combinations.pdf"))

for (ii in seq(1, length(r_L3) - 2)){
  for(jj in seq(ii + 1, length(r_L3) - 1)){
    for(kk in seq(jj + 1, length(r_L3))){
      
      # removing non physical couplings
      if( ((ii == 1) && (jj == 3) && (kk == 4)) || ((ii == 2) && (jj == 3) && (kk == 4)) || ((ii == 3) && (jj == 4) && (kk == 5)))
      {
        next
      }

      mask_r <- c(ii, jj, kk) 
      mask_b <- seq(1, length(b_L3))
      
      rr <- r_L3[mask_r]
      bb <- b_L3[mask_b]
      
      V <- rep(NA, length(rr))
      bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
      g2 <- rep(NA, length(bb))
      bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      
      
      for(i in seq_along(bb))
      {
        folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
          
        for(j in seq_along(rr))
        {
          tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
          
          V[j] <- tmp$t0[[2]]
          bsV[,j] <- tmp$t[,2]
        }
        rm(tmp)
        
        g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
        
        bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
      }
      rm(V)
      rm(bsV)
      
      dg2 <- apply(bsg2, 2, sd)
      
      # Define the random_color function
      random_color <- function() {
        red <- sample(0:255, 1)
        green <- sample(0:255, 1)
        blue <- sample(0:255, 1)
        color <- rgb(red, green, blue, maxColorValue = 255)
        return(color)
      }

      # Generate a random color
      my_color <- random_color()
    
      if((ii == 1) && (jj == 2) && (kk == 3)){
        plotwitherror(bb, g2, dg2, col = my_color, pch = 6, cex = 1,
                      main = paste0("g2(beta), L=3, different derivative discretizations"),
                      xlab = "beta=1/g²", ylab = "r2²F(r2,g)",
                      log = "x",
                      xlim = c(bb[1], bb[length(bb) - 12]), ylim = c(0, 2.4))
        grid()
        
        legend_vec <- c(paste0("r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(my_color)
      }
      else{
        plotwitherror(bb, g2, dg2, col = my_color, pch = 6, cex = 1,
                      rep = TRUE)
        legend_vec <- c(legend_vec, paste0("r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(col_vec, my_color)
      }
    }
  }
}
legend(x = "topright",
       legend = legend_vec,
       pch = 6,
       col = col_vec)
dev.off()
```
-----------------------------------------------------

Step Scaling comparison

```{r}
temporal_extent <- 32
spatial_extent_array <- c(3, 4, 5)
boot.R = 500
x0 = "_0"

col_array <- c("blue", "red", "orange")
pch_lst <- list(c(2, 6), c(1, 1), c(0, 8))
cex_lst <- list(c(1.5, 1.5), c(1.5, 0.5), c(1.5, 1.5))

pdf(paste0(plots_SS, "SS_L.pdf"))

mask_r_L <- list(c(1, 4, 5), c(2, 6, 7), c(4, 8, 9))
mask_b_L <- list(c(4), c(1), c(1))
 
for(spatial_extent_index in seq_along(spatial_extent_array))
{
  spatial_extent <- spatial_extent_array[spatial_extent_index]
  mask_r <- mask_r_L[[spatial_extent_index]]
  mask_b <- mask_b_L[[spatial_extent_index]]
  
  if(spatial_extent == 3)
  {
    rr <- r_L3[mask_r]
    bb <- b_L3[mask_b]
  }
  else if(spatial_extent == 4)
  {
    rr <- r_L4[mask_r]
    bb <- b_L4[mask_b]
  }
  else if(spatial_extent == 5)
  {
    rr <- r_L5[mask_r]
    bb <- b_L5[mask_b]
  }
  
  V <- rep(NA, length(rr))
  bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
  g1 <- rep(NA, length(bb))
  bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  g2 <- rep(NA, length(bb))
  bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  
  
  for(i in seq_along(bb))
  {
    folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
      
    for(j in seq_along(rr))
    {
      tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
      
      V[j] <- tmp$t0[[2]]
      bsV[,j] <- tmp$t[,2]
    }
    rm(tmp)
    
    g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
    g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
    
    bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
    bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
  }
  rm(V)
  rm(bsV)
  
  dg1 <- apply(bsg1, 2, sd)
  dg2 <- apply(bsg2, 2, sd)
  
  col <- col_array[spatial_extent_index]
  pch <- pch_lst[[spatial_extent_index]]
  cex <- cex_lst[[spatial_extent_index]]

  
  # plotting the whole beta range
  if(spatial_extent_index == 1)
  {
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  xlab = "beta=1/g²", ylab = "r²F(r,g)",
                  xlim = c(3, 10), ylim = c(0, 0.55))
    segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
  grid()
  }
  else{
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  rep = TRUE)
        segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
  }
  plotwitherror(bb, g2, dg2, col = col, pch = pch[2], cex = cex[2],
                rep = TRUE)
}

par(xpd=TRUE, mar=c(5, 4, 6, 2))

legend(x = "top",
       inset = c(0, -0.15),
       bty = "n",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "3x3"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "3x3"),
                  expression(r[1]^2 ~ F(r[1], g) ~ "4x4"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "4x4"),
                  expression(r[1]^2 ~ F(r[1], g) ~ "5x5"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "5x5")),
       pch = c(2, 6, 1, 1, 0, 8),  # Point types
       pt.cex = c(1.5, 1.5, 1.5, 0.5, 1.5, 1.5),  # Point sizes
       col = c("blue", "blue", "red", "red", "orange", "orange"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 3)
dev.off()
```
```