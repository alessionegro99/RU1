---
title: "SS."
output:
  html_document: def
---
Loading the required library

```{r}
library(hadron)
```

Initializing stuff

```{r echo = FALSE}
rawdata <- "/home/negro/projects/matching/RU1/01_rawdata/OBC/"
plots <- "/home/negro/projects/matching/RU1/02_output/plots/restricted/OBC/"
datas <- "/home/negro/projects/matching/RU1/02_output/data/OBC/"

## set refinement parameters
boot.l <- 500 # block size
boot.R <- 500 # number of bootstrap samples (usually 200, 500 or 1000)
therm <- 500 # number of configuration to discard for thermalization

## set simulation parameters
TT <- c(32) # array of temporal extents to analyse
SS <- c(3) # array of spatial extents to analyse
BB <- c(2) # array of inverse couplings to analyse
R0 <- 0 # starting point (OBC related)

RMAX <- 3 # max length of Wloops

## array of distances (simulation dependent)
r_i <- c()

for(i in seq(1, RMAX - 1)){
  for(j in seq(0, i)){
    value <- sqrt(i^2 + j^2)
    if(value < RMAX)
      r_i <- c(r_i, value)
  }
}

message("r_i: ", paste(r_i, collapse = ", "))
```

g(beta) for L = 3

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"

mask_r <- c(2, 4, 5)
mask_b <- seq(1, length(b_L3))

rr <- r_L3[mask_r]
bb <- b_L3[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "blue", pch = 2, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "blue", pch = 6, cex = 1.5,
              rep = TRUE)

legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "3x3"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "3x3")),
       pch = c(2, 6),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("blue", "blue"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L=3 P to NP r1 = 1 r2 = sqrt5

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"

mask_r <- c(1, 4, 5)
mask_b <- c(length(b_L3) - 15, length(b_L3) - 12, length(b_L3) - 9, length(b_L3))

rr <- r_L3[mask_r]
bb <- b_L3[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "PtoNP_", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "blue", pch = 2, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "blue", pch = 6, cex = 1.5,
              rep = TRUE)

for(i in rev(seq_along(mask_b))){
  segments(x0 = bb[i], x1 = bb[i], y0 = g1[i], y1 = g2[i], col = "darkgrey", lty = "dashed", lwd = 2)
  if(i!=1){
    segments(x0 = bb[i], x1 = bb[i-1], y0 = g2[i], y1 = g2[i], col = "darkgrey", lty ="dashed", lwd = 2)
  }
}

legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "3x3"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "3x3")),
       pch = c(2, 6),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("blue", "blue"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L=3 NP to P r1 = sqrt(2) r2 = sqrt5

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"

mask_r <- c(2, 4, 5)
mask_b <- c(1, 3, 5, 6, 7,  9)

rr <- r_L3[mask_r]
bb <- b_L3[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "NPtoP_", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "blue", pch = 2, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "blue", pch = 6, cex = 1.5,
              rep = TRUE)

for(i in rev(seq_along(mask_b))){
  segments(x0 = bb[i], x1 = bb[i], y0 = g1[i], y1 = g2[i], col = "darkgrey", lty = "dashed", lwd = 2)
  if(i!=1){
    segments(x0 = bb[i], x1 = bb[i-1], y0 = g2[i], y1 = g2[i], col = "darkgrey", lty ="dashed", lwd = 2)
  }
}

legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "3x3"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "3x3")),
       pch = c(2, 6),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("blue", "blue"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L = 4

```{r}
temporal_extent <- 32
spatial_extent <- 4
boot.R = 500
x0 = "_0"

mask_r <- c(2, 6, 7) # sqrt2 sqrt10 sqrt18
mask_b <- seq(1, length(b_L4))

rr <- r_L4[mask_r]
bb <- b_L4[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "red", pch = 1, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "red", pch = 1, cex = 0.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "4x4"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "4x4")),
       pch = c(1, 1),  # Point types
       pt.cex = c(1.5, 0.5),  # Point sizes
       col = c("red", "red"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L = 5

```{r}
temporal_extent <- 32
spatial_extent <- 5
boot.R = 500
x0 = "_0"

mask_r <- c(4, 8, 9) # sqrt5 5 sqrt32
mask_b <- seq(1, length(b_L5))

rr <- r_L5[mask_r]
bb <- b_L5[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "orange", pch = 0, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 = ",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "orange", pch = 8, cex = 1.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "5x5"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "5x5")),
       pch = c(0, 8),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("orange", "orange"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L = 6

```{r}
temporal_extent <- 32
spatial_extent <- 6
boot.R = 500
x0 = "_0"

mask_r <- c(1, 3, 4) # sqrt2 sqrt5 sqrt8
mask_b <- seq(1, length(b_L6))

rr <- r_L6[mask_r]
bb <- b_L6[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "purple", pch = 2, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "purple", pch = 6, cex = 1.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "6x6"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "6x6")),
       pch = c(2, 6),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("purple", "purple"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L = 7

```{r}
temporal_extent <- 32
spatial_extent <- 7
boot.R = 500
x0 = "_0"

#mask_r <- c(2, 6, 7) # sqrt2 sqrt10 sqrt18
mask_r <- c(4, 10, 11) # sqrt8 sqrt40 sqrt72
mask_b <- seq(1, length(b_L7))

rr <- r_L7[mask_r]
bb <- b_L7[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "darkgreen", pch = 1, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "darkgreen", pch = 1, cex = 0.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "7x7"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "7x7")),
       pch = c(1, 1),  # Point types
       pt.cex = c(1.5, 0.5),  # Point sizes
       col = c("darkgreen", "darkgreen"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g(beta) for L = 8

```{r}
temporal_extent <- 32
spatial_extent <- 8
boot.R = 500
x0 = "_0"

mask_r <- c(3, 8, 9) # sqrt2 sqrt10 sqrt18
mask_b <- seq(1, length(b_L8))

rr <- r_L8[mask_r]
bb <- b_L8[mask_b]

V <- rep(NA, length(rr))
bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
g1 <- rep(NA, length(bb))
bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
g2 <- rep(NA, length(bb))
bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))


for(i in seq_along(bb))
{
  folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
    
  for(j in seq_along(rr))
  {
    tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
    
    V[j] <- tmp$t0[[2]]
    bsV[,j] <- tmp$t[,2]
  }
  rm(tmp)
  
  g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
  g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
  
  bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
  bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
}
rm(V)
rm(bsV)

dg1 <- apply(bsg1, 2, sd)
dg2 <- apply(bsg2, 2, sd)

# plotting the whole beta range
pdf(paste0(plots_SS, "g1_g2_vs_beta_L", spatial_extent, "_", round(rr[1],2),"_",  round(rr[2],2), "_", round(rr[3],2), ".pdf"))
plotwitherror(bb, g1, dg1, col = "magenta", pch = 0, cex = 1.5,
              main = paste0("g1(beta), g2(beta), L =", spatial_extent, " , r1 = ", round(rr[1], 2),", r2 =",  round(rr[2], 2), " , r3 = ", round(rr[3], 2)),
              xlab = "beta=1/g²", ylab = "r²F(r,g)",
              log = "x",
              xlim = c(bb[1], bb[length(bb)]), ylim = c(0, g2[1] + dg2[1]))
grid()
plotwitherror(bb, g2, dg2, col = "magenta", pch = 8, cex = 1.5,
              rep = TRUE)
legend(x = "topright",
       legend = c(expression(r[1]^2 ~ F(r[1], g) ~ "8x8"), 
                  expression(r[2]^2 ~ F(r[2], g) ~ "8x8")),
       pch = c(0, 8),  # Point types
       pt.cex = c(1.5, 1.5),  # Point sizes
       col = c("magenta", "magenta"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 2)
dev.off()
```

g1,g2(beta) for L = 3, every possible discretization of the derivative, combined

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"
pdf(paste0(plots_SS, "g1_g2_vs_beta_L_combinations.pdf"))

for (ii in seq(1, length(r_L3) - 2)){
  for(jj in seq(ii + 1, length(r_L3) - 1)){
    for(kk in seq(jj + 1, length(r_L3))){
      
      # removing non physical couplings
      if( ((ii == 1) && (jj == 3) && (kk == 4)) || ((ii == 2) && (jj == 3) && (kk == 4)) || ((ii == 3) && (jj == 4) && (kk == 5)))
      {
        next
      }

      mask_r <- c(ii, jj, kk) 
      mask_b <- seq(1, length(b_L3))
      
      rr <- r_L3[mask_r]
      bb <- b_L3[mask_b]
      
      V <- rep(NA, length(rr))
      bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
      g1 <- rep(NA, length(bb))
      bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      g2 <- rep(NA, length(bb))
      bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      
      for(i in seq_along(bb))
      {
        folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
          
        for(j in seq_along(rr))
        {
          tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
          
          V[j] <- tmp$t0[[2]]
          bsV[,j] <- tmp$t[,2]
        }
        rm(tmp)
        
        g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
        g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])


        bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
        bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])

      }
      rm(V)
      rm(bsV)
      
      dg1 <- apply(bsg1, 2, sd)
      dg2 <- apply(bsg2, 2, sd)
      
      # Define the random_color function
      random_color <- function() {
        red <- sample(0:255, 1)
        green <- sample(0:255, 1)
        blue <- sample(0:255, 1)
        color <- rgb(red, green, blue, maxColorValue = 255)
        return(color)
      }

      # Generate a random color
      my_color <- random_color()
    
      if((ii == 1) && (jj == 2) && (kk == 3)){
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      main = paste0("g1(beta), g2(beta), L=3, different derivative discretizations"),
                      xlab = "beta=1/g²", ylab = "r²F(r,g)",
                      log = "x",
                      xlim = c(bb[1], bb[length(bb) - 12]), ylim = c(0, 2.4))
        grid()
        
        legend_vec <- c(paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(my_color)
      }
      else{
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      rep = TRUE)
        legend_vec <- c(legend_vec, paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(col_vec, my_color)
      }
      plotwitherror(bb, g2, dg2, col = my_color, pch = 6, cex = 1,
                    rep = TRUE)
    }
  }
}
legend(x = "topright",
       legend = legend_vec,
       pch = 11,
       col = col_vec)
dev.off()
```

g1(beta) for L = 3, every possible discretization of the derivative, combined

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"
pdf(paste0(plots_SS, "g1_vs_beta_L_combinations.pdf"))

for (ii in seq(1, length(r_L3) - 2)){
  for(jj in seq(ii + 1, length(r_L3) - 1)){
    for(kk in seq(jj + 1, length(r_L3))){
      
      # removing non physical couplings
      if( ((ii == 1) && (jj == 3) && (kk == 4)) || ((ii == 2) && (jj == 3) && (kk == 4)) || ((ii == 3) && (jj == 4) && (kk == 5)))
      {
        next
      }

      mask_r <- c(ii, jj, kk) 
      mask_b <- seq(1, length(b_L3))
      
      rr <- r_L3[mask_r]
      bb <- b_L3[mask_b]
      
      V <- rep(NA, length(rr))
      bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
      g1 <- rep(NA, length(bb))
      bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      
      for(i in seq_along(bb))
      {
        folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
          
        for(j in seq_along(rr))
        {
          tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
          
          V[j] <- tmp$t0[[2]]
          bsV[,j] <- tmp$t[,2]
        }
        rm(tmp)
        
        g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])

        bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
      }
      rm(V)
      rm(bsV)
      
      dg1 <- apply(bsg1, 2, sd)
      dg2 <- apply(bsg2, 2, sd)
      
      # Define the random_color function
      random_color <- function() {
        red <- sample(0:255, 1)
        green <- sample(0:255, 1)
        blue <- sample(0:255, 1)
        color <- rgb(red, green, blue, maxColorValue = 255)
        return(color)
      }

      # Generate a random color
      my_color <- random_color()
    
      if((ii == 1) && (jj == 2) && (kk == 3)){
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      main = paste0("g1(beta), L=3, different derivative discretizations"),
                      xlab = "beta=1/g²", ylab = "r1²F(r1,g)",
                      log = "x",
                      xlim = c(bb[1], bb[length(bb) - 12]), ylim = c(0, 0.85))
        grid()
        
        legend_vec <- c(paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2)))
        col_vec <- c(my_color)
      }
      else{
        plotwitherror(bb, g1, dg1, col = my_color, pch = 2, cex = 1,
                      rep = TRUE)
        legend_vec <- c(legend_vec, paste0("r1=", round(rr[1],2), ", r2=", round(rr[2],2)))
        col_vec <- c(col_vec, my_color)
      }
    }
  }
}
legend(x = "topright",
       legend = legend_vec,
       pch = 2,
       col = col_vec)
dev.off()
```

g2(beta) for L = 3, every possible discretization of the derivative, combined

```{r}
temporal_extent <- 32
spatial_extent <- 3
boot.R = 500
x0 = "_0"
pdf(paste0(plots_SS, "g2_vs_beta_L_combinations.pdf"))

for (ii in seq(1, length(r_L3) - 2)){
  for(jj in seq(ii + 1, length(r_L3) - 1)){
    for(kk in seq(jj + 1, length(r_L3))){
      
      # removing non physical couplings
      if( ((ii == 1) && (jj == 3) && (kk == 4)) || ((ii == 2) && (jj == 3) && (kk == 4)) || ((ii == 3) && (jj == 4) && (kk == 5)))
      {
        next
      }

      mask_r <- c(ii, jj, kk) 
      mask_b <- seq(1, length(b_L3))
      
      rr <- r_L3[mask_r]
      bb <- b_L3[mask_b]
      
      V <- rep(NA, length(rr))
      bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
      g2 <- rep(NA, length(bb))
      bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
      
      
      for(i in seq_along(bb))
      {
        folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
          
        for(j in seq_along(rr))
        {
          tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
          
          V[j] <- tmp$t0[[2]]
          bsV[,j] <- tmp$t[,2]
        }
        rm(tmp)
        
        g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
        
        bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
      }
      rm(V)
      rm(bsV)
      
      dg2 <- apply(bsg2, 2, sd)
      
      # Define the random_color function
      random_color <- function() {
        red <- sample(0:255, 1)
        green <- sample(0:255, 1)
        blue <- sample(0:255, 1)
        color <- rgb(red, green, blue, maxColorValue = 255)
        return(color)
      }

      # Generate a random color
      my_color <- random_color()
    
      if((ii == 1) && (jj == 2) && (kk == 3)){
        plotwitherror(bb, g2, dg2, col = my_color, pch = 6, cex = 1,
                      main = paste0("g2(beta), L=3, different derivative discretizations"),
                      xlab = "beta=1/g²", ylab = "r2²F(r2,g)",
                      log = "x",
                      xlim = c(bb[1], bb[length(bb) - 12]), ylim = c(0, 2.4))
        grid()
        
        legend_vec <- c(paste0("r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(my_color)
      }
      else{
        plotwitherror(bb, g2, dg2, col = my_color, pch = 6, cex = 1,
                      rep = TRUE)
        legend_vec <- c(legend_vec, paste0("r2=", round(rr[2],2), ", r3=", round(rr[3],2)))
        col_vec <- c(col_vec, my_color)
      }
    }
  }
}
legend(x = "topright",
       legend = legend_vec,
       pch = 6,
       col = col_vec)
dev.off()
```

Step Scaling comparison L = 3,4,5

```{r}
temporal_extent <- 32
spatial_extent_array <- c(3, 4, 5)
boot.R = 500
x0 = "_0"

col_array <- c("blue", "red", "orange")
pch_lst <- list(c(2, 6), c(1, 1), c(0, 8))
cex_lst <- list(c(1.5, 1.5), c(1.5, 0.5), c(1.5, 1.5))

pdf(paste0(plots_SS, "SS_L.pdf"))

mask_r_L <- list(c(1, 4, 5), c(2, 6, 7), c(4, 8, 9))
mask_b_L <- list(c(4), c(5), c(6))

x_plot <- rep(NA, length(spatial_extent_array))
y_plot <- rep(NA, length(spatial_extent_array))
bsy_plot <- matrix(NA, nrow = boot.R, ncol = length(spatial_extent_array))

x_plot2 <- rep(NA, length(spatial_extent_array))
y_plot2 <- rep(NA, length(spatial_extent_array))
bsy_plot2 <- matrix(NA, nrow = boot.R, ncol = length(spatial_extent_array))
 
for(spatial_extent_index in seq_along(spatial_extent_array))
{
  spatial_extent <- spatial_extent_array[spatial_extent_index]
  mask_r <- mask_r_L[[spatial_extent_index]]
  mask_b <- mask_b_L[[spatial_extent_index]]
  
  if(spatial_extent == 3)
  {
    rr <- r_L3[mask_r]
    bb <- b_L3[mask_b]
  }
  else if(spatial_extent == 4)
  {
    rr <- r_L4[mask_r]
    bb <- b_L4[mask_b]
  }
  else if(spatial_extent == 5)
  {
    rr <- r_L5[mask_r]
    bb <- b_L5[mask_b]
  }
  
  V <- rep(NA, length(rr))
  bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
  g1 <- rep(NA, length(bb))
  bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  g2 <- rep(NA, length(bb))
  bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  
  
  for(i in seq_along(bb))
  {
    folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
      
    for(j in seq_along(rr))
    {
      tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
      
      V[j] <- tmp$t0[[2]]
      bsV[,j] <- tmp$t[,2]
    }
    rm(tmp)
    
    g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
    g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
    
    bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
    bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
  }
  rm(V)
  rm(bsV)
  
  dg1 <- apply(bsg1, 2, sd)
  dg2 <- apply(bsg2, 2, sd)
  
  col <- col_array[spatial_extent_index]
  pch <- pch_lst[[spatial_extent_index]]
  cex <- cex_lst[[spatial_extent_index]]

  
  # plotting the whole beta range
  if(spatial_extent_index == 1)
  {
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  xlab = "beta=1/g²", ylab = "r²F(r,g)",
                  xlim = c(3, 12), ylim = c(0.05, 0.475), xaxt = "n")
    segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
    segments(x0 = bb[1], x1 = bb[1], y0 = 0, y1 = g1[1], col = "lightgray", lty = "dotted", lwd = 2)
    axis(1, at = bb[1], labels = bb[1])
  grid()
  }
  else{
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  rep = TRUE)
        segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
        segments(x0 = bb[1], x1 = bb[1], y0 = 0, y1 = g1[1], col = "lightgray", lty = "dotted", lwd = 2)
        axis(1, at = bb[1], labels = bb[1])
  }
  plotwitherror(bb, g2, dg2, col = col, pch = pch[2], cex = cex[2],
                rep = TRUE)
  x_plot[spatial_extent_index] <- 1/(rr[1]*rr[1])
  y_plot[spatial_extent_index] <- g1[1]
  bsy_plot[,spatial_extent_index] <- bsg1[,1]
  
  x_plot2[spatial_extent_index] <- 1/(rr[2]*rr[2])
  y_plot2[spatial_extent_index] <- g2[1]
  bsy_plot2[,spatial_extent_index] <- bsg2[,1]

}

par(xpd=TRUE, mar=c(5, 4, 6, 2))

legend(x = "top",
       inset = c(0, -0.15),
       bty = "n",
       legend = c(expression(r[1]^2 ~ F(r[1] == 1 , g) ~ "3x3"), 
                  expression(r[2]^2 ~ F(r[2] == 2.24, g) ~ "3x3"),
                  expression(r[1]^2 ~ F(r[1] == 1.4, g) ~ "4x4"), 
                  expression(r[2]^2 ~ F(r[2] == 3.16, g) ~ "4x4"),
                  expression(r[1]^2 ~ F(r[1] == 2.24, g) ~ "5x5"), 
                  expression(r[2]^2 ~ F(r[2] == 5, g) ~ "5x5")),
       pch = c(2, 6, 1, 1, 0, 8),  # Point types
       pt.cex = c(1.5, 1.5, 1.5, 0.5, 1.5, 1.5),  # Point sizes
       col = c("blue", "blue", "red", "red", "orange", "orange"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 3)
dev.off()
```

```{r}
pdf(paste0(plots_SS, "SS_g1_fit.pdf"))
fn <- function(par, x, boot.r,...) par[1] + par[2]*x
fit.result <- bootstrap.nlsfit(fn = fn, par.guess = c(1,1), y = y_plot, x = x_plot, bsamples = bsy_plot)
summary(fit.result)
par(xpd=FALSE, mar=c(4.5, 4.5, 4, 3) + 0.1)
plot(fit.result, pch = c(2,1,0), cex = 1.5, col = c("blue", "red", "orange"), xlab = expression(1/r[latt]^2), ylab = expression(r[latt]^2 ~ F(r[latt], g)))
legend(x = "topleft", legend = c(paste0("a = ", round(fit.result$t0[1],4)) , paste0("da = ", round(fit.result$se[1],4)), paste0("b = ", round(fit.result$t0[2],3)), paste0("db = ", round(fit.result$se[2],4))))
grid()
dev.off()
```

```{r}
pdf(paste0(plots_SS, "SS_g2_fit.pdf"))
fn <- function(par, x, boot.r,...) par[1] + par[2]*x
fit.result <- bootstrap.nlsfit(fn = fn, par.guess = c(1,1), y = y_plot2, x = x_plot2, bsamples = bsy_plot2)
summary(fit.result)
par(xpd=FALSE, mar=c(4.5, 4.5, 4, 3) + 0.1)
plot(fit.result, pch = c(2,1,0), cex = 1.5, col = c("blue", "red", "orange"), xlab = expression(1/r[latt]^2), ylab = expression(r[latt]^2 ~ F(r[latt], g)))
legend(x = "topleft", legend = c(paste0("a = ", round(fit.result$t0[1],4)) , paste0("da = ", round(fit.result$se[1],4)), paste0("b = ", round(fit.result$t0[2],3)), paste0("db = ", round(fit.result$se[2],4))))
grid()
dev.off()
```

Step Scaling comparison L = 6,7,8

```{r}
temporal_extent <- 32
spatial_extent_array <- c(6, 7, 8)
boot.R = 500
x0 = "_0"

col_array <- c("purple", "darkgreen", "magenta")
pch_lst <- list(c(2, 6), c(1, 1), c(0, 8))
cex_lst <- list(c(1.5, 1.5), c(1.5, 0.5), c(1.5, 1.5))

pdf(paste0(plots_SS, "SS_L_6_7_8.pdf"))

mask_r_L <- list(c(1, 3, 4), c(2, 6, 7), c(3, 8, 9))
mask_b_L <- list(c(1), c(4), c(3))

x_plot <- rep(NA, length(spatial_extent_array))
y_plot <- rep(NA, length(spatial_extent_array))
bsy_plot <- matrix(NA, nrow = boot.R, ncol = length(spatial_extent_array))

x_plot2 <- rep(NA, length(spatial_extent_array))
y_plot2 <- rep(NA, length(spatial_extent_array))
bsy_plot2 <- matrix(NA, nrow = boot.R, ncol = length(spatial_extent_array))
 
for(spatial_extent_index in seq_along(spatial_extent_array))
{
  spatial_extent <- spatial_extent_array[spatial_extent_index]
  mask_r <- mask_r_L[[spatial_extent_index]]
  mask_b <- mask_b_L[[spatial_extent_index]]
  
  if(spatial_extent == 6)
  {
    rr <- r_L6[mask_r]
    bb <- b_L6[mask_b]
  }
  else if(spatial_extent == 7)
  {
    rr <- r_L7[mask_r]
    bb <- b_L7[mask_b]
  }
  else if(spatial_extent == 8)
  {
    rr <- r_L8[mask_r]
    bb <- b_L8[mask_b]
  }
  
  V <- rep(NA, length(rr))
  bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
  g1 <- rep(NA, length(bb))
  bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  g2 <- rep(NA, length(bb))
  bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  
  
  for(i in seq_along(bb))
  {
    folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
      
    for(j in seq_along(rr))
    {
      tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
      
      V[j] <- tmp$t0[[2]]
      bsV[,j] <- tmp$t[,2]
    }
    rm(tmp)
    
    g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
    g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
    
    bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
    bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
  }
  rm(V)
  rm(bsV)
  
  dg1 <- apply(bsg1, 2, sd)
  dg2 <- apply(bsg2, 2, sd)
  
  col <- col_array[spatial_extent_index]
  pch <- pch_lst[[spatial_extent_index]]
  cex <- cex_lst[[spatial_extent_index]]

  
  # plotting the whole beta range
  if(spatial_extent_index == 1)
  {
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  xlab = "beta=1/g²", ylab = "r²F(r,g)",
                  xlim = c(5, 15), ylim = c(0.025, 0.105), xaxt = "n")
    segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
    segments(x0 = bb[1], x1 = bb[1], y0 = 0, y1 = g1[1], col = "lightgray", lty = "dotted", lwd = 2)
    axis(1, at = bb[1], labels = bb[1])
  grid()
  }
  else{
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  rep = TRUE)
        segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
        segments(x0 = bb[1], x1 = bb[1], y0 = 0, y1 = g1[1], col = "lightgray", lty = "dotted", lwd = 2)
        axis(1, at = bb[1], labels = bb[1])
  }
  plotwitherror(bb, g2, dg2, col = col, pch = pch[2], cex = cex[2],
                rep = TRUE)
  x_plot[spatial_extent_index] <- 1/(rr[1]*rr[1])
  y_plot[spatial_extent_index] <- g1[1]
  bsy_plot[,spatial_extent_index] <- bsg1[,1]
  
  x_plot2[spatial_extent_index] <- 1/(rr[2]*rr[2])
  y_plot2[spatial_extent_index] <- g2[1]
  bsy_plot2[,spatial_extent_index] <- bsg2[,1]

}

par(xpd=TRUE, mar=c(5, 4, 6, 2))

legend(x = "top",
       inset = c(0, -0.15),
       bty = "n",
       legend = c(expression(r[1]^2 ~ F(r[1] == 1 , g) ~ "6x6"), 
                  expression(r[2]^2 ~ F(r[2] == 2.24, g) ~ "6x6"),
                  expression(r[1]^2 ~ F(r[1] == 1.4, g) ~ "7x7"), 
                  expression(r[2]^2 ~ F(r[2] == 3.16, g) ~ "7x7"),
                  expression(r[1]^2 ~ F(r[1] == 2.24, g) ~ "8x8"), 
                  expression(r[2]^2 ~ F(r[2] == 5, g) ~ "8x8")),
       pch = c(2, 6, 1, 1, 0, 8),  # Point types
       pt.cex = c(1.5, 1.5, 1.5, 0.5, 1.5, 1.5),  # Point sizes
       col = c("purple", "purple", "darkgreen", "darkgreen", "magenta", "magenta"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 3)
dev.off()
```

```{r}
pdf(paste0(plots_SS, "SS_g1_fit.pdf"))
fn <- function(par, x, boot.r,...) par[1] + par[2]*x
fit.result <- bootstrap.nlsfit(fn = fn, par.guess = c(1,1), y = y_plot, x = x_plot, bsamples = bsy_plot)
summary(fit.result)
par(xpd=FALSE, mar=c(4.5, 4.5, 4, 3) + 0.1)
plot(fit.result, pch = c(2,1,0), cex = 1.5, col = c("blue", "red", "orange"), xlab = expression(1/r[latt]^2), ylab = expression(r[latt]^2 ~ F(r[latt], g)))
legend(x = "topleft", legend = c(paste0("a = ", round(fit.result$t0[1],4)) , paste0("da = ", round(fit.result$se[1],4)), paste0("b = ", round(fit.result$t0[2],3)), paste0("db = ", round(fit.result$se[2],4))))
grid()
dev.off()
```

```{r}
pdf(paste0(plots_SS, "SS_g2_fit.pdf"))
fn <- function(par, x, boot.r,...) par[1] + par[2]*x
fit.result <- bootstrap.nlsfit(fn = fn, par.guess = c(1,1), y = y_plot2, x = x_plot2, bsamples = bsy_plot2)
summary(fit.result)
par(xpd=FALSE, mar=c(4.5, 4.5, 4, 3) + 0.1)
plot(fit.result, pch = c(2,1,0), cex = 1.5, col = c("blue", "red", "orange"), xlab = expression(1/r[latt]^2), ylab = expression(r[latt]^2 ~ F(r[latt], g)))
legend(x = "topleft", legend = c(paste0("a = ", round(fit.result$t0[1],4)) , paste0("da = ", round(fit.result$se[1],4)), paste0("b = ", round(fit.result$t0[2],3)), paste0("db = ", round(fit.result$se[2],4))))
grid()
dev.off()
```

Step Scaling comparison L = 3, 4, 5, 7, 8, 9

```{r}
temporal_extent <- 32
spatial_extent_array <- c(3, 4, 5, 7, 8)
boot.R = 500
x0 = "_0"

col_array <- c("blue", "red", "orange", "purple", "darkgreen", "darkgreen")
pch_lst <- list(c(2, 6), c(1, 1), c(0, 8), c(10, 11), c(12,13))
cex_lst <- list(c(1.5, 1.5), c(1.5, 0.5), c(1.5, 1.5), c(1.5, 1.5), c(1.5, 1.5))

pdf(paste0(plots_SS, "SS_L_3_4_5_7_8.pdf"))

mask_r_L <- list(c(1, 4, 5), c(2, 6, 7), c(4, 8, 9), c(4, 10, 11), c(6, 12, 13))
mask_b_L <- list(c(4), c(5), c(6), c(3), c(3))

x_plot <- rep(NA, length(spatial_extent_array))
y_plot <- rep(NA, length(spatial_extent_array))
bsy_plot <- matrix(NA, nrow = boot.R, ncol = length(spatial_extent_array))

x_plot2 <- rep(NA, length(spatial_extent_array))
y_plot2 <- rep(NA, length(spatial_extent_array))
bsy_plot2 <- matrix(NA, nrow = boot.R, ncol = length(spatial_extent_array))
 
for(spatial_extent_index in seq_along(spatial_extent_array))
{
  spatial_extent <- spatial_extent_array[spatial_extent_index]
  mask_r <- mask_r_L[[spatial_extent_index]]
  mask_b <- mask_b_L[[spatial_extent_index]]
  
  if(spatial_extent == 3)
  {
    rr <- r_L3[mask_r]
    bb <- b_L3[mask_b]
  }
  else if(spatial_extent == 4)
  {
    rr <- r_L4[mask_r]
    bb <- b_L4[mask_b]
  }
  else if(spatial_extent == 5)
  {
    rr <- r_L5[mask_r]
    bb <- b_L5[mask_b]
  }
  
  else if(spatial_extent == 7)
  {
    rr <- r_L7[mask_r]
    bb <- b_L7[mask_b]
  }
  
  else if(spatial_extent == 8)
  {
    rr <- r_L8[mask_r]
    bb <- b_L8[mask_b]
  }
  
  V <- rep(NA, length(rr))
  bsV <- matrix(NA, nrow = boot.R, ncol = length(rr))
  g1 <- rep(NA, length(bb))
  bsg1 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  g2 <- rep(NA, length(bb))
  bsg2 <- matrix(NA, nrow = boot.R, ncol = length(bb))
  
  
  for(i in seq_along(bb))
  {
    folder <- paste0("pascal_OBC_", bb[i], "_", spatial_extent, "_", temporal_extent, x0)
      
    for(j in seq_along(rr))
    {
      tmp <- readRDS(paste0(data, folder, "/fit.result_correlated_", mask_r[j], ".rds"))
      
      V[j] <- tmp$t0[[2]]
      bsV[,j] <- tmp$t[,2]
    }
    rm(tmp)
    
    g1[i] <- rr[1]*rr[1]*(V[2]-V[1])/(rr[2]-rr[1])
    g2[i] <- rr[2]*rr[2]*(V[3]-V[2])/(rr[3]-rr[2])
    
    bsg1[, i] <- rr[1]*rr[1]*(bsV[, 2]-bsV[, 1])/(rr[2] - rr[1])
    bsg2[, i] <- rr[2]*rr[2]*(bsV[, 3]-bsV[, 2])/(rr[3] - rr[2])
  }
  rm(V)
  rm(bsV)
  
  dg1 <- apply(bsg1, 2, sd)
  dg2 <- apply(bsg2, 2, sd)
  
  col <- col_array[spatial_extent_index]
  pch <- pch_lst[[spatial_extent_index]]
  cex <- cex_lst[[spatial_extent_index]]

  
  # plotting the whole beta range
  if(spatial_extent_index == 1)
  {
    par(mar=c(4, 4, 7, 3))
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  xlab = "beta=1/g²", ylab = "r²F(r,g)",
                  xlim = c(3, 20), ylim = c(0.05, 0.475), xaxt = "n")
    segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
    segments(x0 = bb[1], x1 = bb[1], y0 = 0, y1 = g1[1], col = "lightgray", lty = "dotted", lwd = 2)
    axis(1, at = bb[1], labels = bb[1])
  grid()
  }
  else{
    plotwitherror(bb, g1, dg1, col = col, pch = pch[1], cex = cex[1],
                  rep = TRUE)
        segments(x0 = bb[1], x1 = bb[1], y0 = g1[1], y1 = g2[1], col = col, lty = "dashed", lwd = 2)
        segments(x0 = bb[1], x1 = bb[1], y0 = 0, y1 = g1[1], col = "lightgray", lty = "dotted", lwd = 2)
        axis(1, at = bb[1], labels = bb[1])
  }
  plotwitherror(bb, g2, dg2, col = col, pch = pch[2], cex = cex[2],
                rep = TRUE)
  x_plot[spatial_extent_index] <- 1/(rr[1]*rr[1])
  y_plot[spatial_extent_index] <- g1[1]
  bsy_plot[,spatial_extent_index] <- bsg1[,1]
  
  x_plot2[spatial_extent_index] <- 1/(rr[2]*rr[2])
  y_plot2[spatial_extent_index] <- g2[1]
  bsy_plot2[,spatial_extent_index] <- bsg2[,1]

}

par(xpd=TRUE)

legend(x = "top",
       inset = c(0, -0.3),
       bty = "n",
       legend = c(expression(r[1]^2 ~ F(r[1] == 1 , g) ~ "3x3"), 
                  expression(r[2]^2 ~ F(r[2] == 2.24, g) ~ "3x3"),
                  expression(r[1]^2 ~ F(r[1] == 1.4, g) ~ "4x4"), 
                  expression(r[2]^2 ~ F(r[2] == 3.16, g) ~ "4x4"),
                  expression(r[1]^2 ~ F(r[1] == 2.24, g) ~ "5x5"), 
                  expression(r[2]^2 ~ F(r[2] == 5, g) ~ "5x5"),
                  expression(r[1]^2 ~ F(r[1] == 2.83, g) ~ "7x7"), 
                  expression(r[2]^2 ~ F(r[2] == 6.32, g) ~ "7x7"),
                  expression(r[1]^2 ~ F(r[1] == 3.16, g) ~ "8x8"), 
                  expression(r[2]^2 ~ F(r[2] == 6.71, g) ~ "8x8")),
       pch = c(2, 6, 1, 1, 0, 8, 10, 11, 12, 13),  # Point types
       pt.cex = c(1.5, 1.5, 1.5, 0.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5),  # Point sizes
       col = c("blue", "blue", "red", "red", "orange", "orange", "purple", "purple", "darkgreen", "darkgreen"),  # Colors
       y.intersp = 1.5,  # Vertical spacing
       ncol = 3)
dev.off()
```

```{r}
pdf(paste0(plots_SS, "SS_g1_fit.pdf"))
fn <- function(par, x, boot.r,...) par[1] + par[2]*x
fit.result <- bootstrap.nlsfit(fn = fn, par.guess = c(1,1), y = y_plot, x = x_plot, bsamples = bsy_plot)
summary(fit.result)
par(xpd=FALSE, mar=c(4.5, 4.5, 4, 3) + 0.1)
plot(fit.result, pch = c(2,1,0), cex = 1.5, col = c("blue", "red", "orange"), xlab = expression(1/r[latt]^2), ylab = expression(r[latt]^2 ~ F(r[latt], g)))
legend(x = "topleft", legend = c(paste0("a = ", round(fit.result$t0[1],4)) , paste0("da = ", round(fit.result$se[1],4)), paste0("b = ", round(fit.result$t0[2],3)), paste0("db = ", round(fit.result$se[2],4))))
grid()
dev.off()
```

```{r}
pdf(paste0(plots_SS, "SS_g2_fit.pdf"))
fn <- function(par, x, boot.r,...) par[1] + par[2]*x
fit.result <- bootstrap.nlsfit(fn = fn, par.guess = c(1,1), y = y_plot2, x = x_plot2, bsamples = bsy_plot2)
summary(fit.result)
par(xpd=FALSE, mar=c(4.5, 4.5, 4, 3) + 0.1)
plot(fit.result, pch = c(2,1,0), cex = 1.5, col = c("blue", "red", "orange"), xlab = expression(1/r[latt]^2), ylab = expression(r[latt]^2 ~ F(r[latt], g)))
legend(x = "topleft", legend = c(paste0("a = ", round(fit.result$t0[1],4)) , paste0("da = ", round(fit.result$se[1],4)), paste0("b = ", round(fit.result$t0[2],3)), paste0("db = ", round(fit.result$se[2],4))))
grid()
dev.off()
```